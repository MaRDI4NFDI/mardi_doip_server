{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the documentation for the strict DOIP v2.0 server and client. Why DOIP and FDO? FAIR Digital Objects (FDOs) provide a persistent, structured way to describe research outputs. They carry metadata, identifiers, and links to content, enabling interoperability and long-term access. Digital Object Interface Protocol (DOIP) defines how to retrieve and operate on FDOs over the network using a consistent binary envelope. DOIP 2.0 specifies headers, block framing, and operation codes so clients and servers can exchange objects reliably. This implementation offers a strict DOIP v2.0 server and client so MARDI services can publish and consume FDO content (bitstreams, derived components, workflows) in a predictable, standards-based way. What\u2019s here Server listens on TCP (default 3567) and uses strict DOIP framing. Client implements strict DOIP v2.0 over TCP/TLS with hello, list_ops, and retrieve. Use the navigation to learn more about server handlers and client usage. Quick start example Run the server (plaintext for local testing) and call it with the client: # Terminal 1 PYTHONPATH=. python -m doip_server.main --port 3567 # Terminal 2 PYTHONPATH=. python -m client_cli.main --host 127.0.0.1 --port 3567 --no-tls --action retrieve --object-id Q6190920 --output . The client will issue hello and retrieve requests using strict DOIP framing, print the returned metadata and component counts, and save the first component (using the server-provided filename when available).","title":"Home"},{"location":"#why-doip-and-fdo","text":"FAIR Digital Objects (FDOs) provide a persistent, structured way to describe research outputs. They carry metadata, identifiers, and links to content, enabling interoperability and long-term access. Digital Object Interface Protocol (DOIP) defines how to retrieve and operate on FDOs over the network using a consistent binary envelope. DOIP 2.0 specifies headers, block framing, and operation codes so clients and servers can exchange objects reliably. This implementation offers a strict DOIP v2.0 server and client so MARDI services can publish and consume FDO content (bitstreams, derived components, workflows) in a predictable, standards-based way.","title":"Why DOIP and FDO?"},{"location":"#whats-here","text":"Server listens on TCP (default 3567) and uses strict DOIP framing. Client implements strict DOIP v2.0 over TCP/TLS with hello, list_ops, and retrieve. Use the navigation to learn more about server handlers and client usage.","title":"What\u2019s here"},{"location":"#quick-start-example","text":"Run the server (plaintext for local testing) and call it with the client: # Terminal 1 PYTHONPATH=. python -m doip_server.main --port 3567 # Terminal 2 PYTHONPATH=. python -m client_cli.main --host 127.0.0.1 --port 3567 --no-tls --action retrieve --object-id Q6190920 --output . The client will issue hello and retrieve requests using strict DOIP framing, print the returned metadata and component counts, and save the first component (using the server-provided filename when available).","title":"Quick start example"},{"location":"client/","text":"Overview doip_client implements a strict DOIP v2.0 client that matches the server framing. Key operations hello() : Perform hello/health check. list_ops() : Fetch available operations. retrieve(object_id, component=None) : Retrieve metadata and components. invoke(object_id, workflow, params=None) : Trigger a workflow on the server. Usage from doip_client import StrictDOIPClient client = StrictDOIPClient(host=\"127.0.0.1\", port=3567, use_tls=False) hello = client.hello() retrieve = client.retrieve(\"Q123\") invoke = client.invoke(\"Q123\", workflow=\"equation_extraction\", params={}) Command-line example: PYTHONPATH=. python -m client_cli.main --host 127.0.0.1 --port 3567 --no-tls --object-id Q123 Protocol Header: >BBBBHI Blocks: metadata (0x01), component (0x02), workflow (0x03) See doip_client/protocol.py for client-side framing helpers.","title":"Client"},{"location":"client/#overview","text":"doip_client implements a strict DOIP v2.0 client that matches the server framing.","title":"Overview"},{"location":"client/#key-operations","text":"hello() : Perform hello/health check. list_ops() : Fetch available operations. retrieve(object_id, component=None) : Retrieve metadata and components. invoke(object_id, workflow, params=None) : Trigger a workflow on the server.","title":"Key operations"},{"location":"client/#usage","text":"from doip_client import StrictDOIPClient client = StrictDOIPClient(host=\"127.0.0.1\", port=3567, use_tls=False) hello = client.hello() retrieve = client.retrieve(\"Q123\") invoke = client.invoke(\"Q123\", workflow=\"equation_extraction\", params={}) Command-line example: PYTHONPATH=. python -m client_cli.main --host 127.0.0.1 --port 3567 --no-tls --object-id Q123","title":"Usage"},{"location":"client/#protocol","text":"Header: >BBBBHI Blocks: metadata (0x01), component (0x02), workflow (0x03) See doip_client/protocol.py for client-side framing helpers.","title":"Protocol"},{"location":"client_cli/","text":"The client_cli module provides a minimal command-line interface around the strict DOIP client. Running PYTHONPATH=. python -m client_cli.main --host 127.0.0.1 --port 3567 --no-tls --object-id Q123 Options: - --host : Server host (default 127.0.0.1 ) - --port : Server port (default 3567 ) - --no-tls : Disable TLS wrapping (useful for local plaintext servers) - --insecure : Disable TLS certificate/hostname verification - --object-id : Object identifier to retrieve (default Q123 ) - --action : One of demo , hello , retrieve , invoke (default demo ) - --component : Component ID to retrieve (retrieve/demo actions) - --workflow : Workflow name (invoke action, default equation_extraction ) - --params : Workflow parameters as JSON string (invoke action) - --output : Path or directory to save the first retrieved component (retrieve action) Actions demo : Runs hello then retrieve . hello : Runs only the hello operation. retrieve : Runs retrieve for the given object (and optional component). invoke : Runs a workflow for the given object with optional params. The CLI prints the resulting metadata and component counts for each action. Example: download a PDF PYTHONPATH=. python -m client_cli.main --action retrieve --object-id Q6190920 --output . This saves the first returned component to the current directory, honoring the server-provided original filename when available.","title":"Client CLI"},{"location":"client_cli/#running","text":"PYTHONPATH=. python -m client_cli.main --host 127.0.0.1 --port 3567 --no-tls --object-id Q123 Options: - --host : Server host (default 127.0.0.1 ) - --port : Server port (default 3567 ) - --no-tls : Disable TLS wrapping (useful for local plaintext servers) - --insecure : Disable TLS certificate/hostname verification - --object-id : Object identifier to retrieve (default Q123 ) - --action : One of demo , hello , retrieve , invoke (default demo ) - --component : Component ID to retrieve (retrieve/demo actions) - --workflow : Workflow name (invoke action, default equation_extraction ) - --params : Workflow parameters as JSON string (invoke action) - --output : Path or directory to save the first retrieved component (retrieve action)","title":"Running"},{"location":"client_cli/#actions","text":"demo : Runs hello then retrieve . hello : Runs only the hello operation. retrieve : Runs retrieve for the given object (and optional component). invoke : Runs a workflow for the given object with optional params. The CLI prints the resulting metadata and component counts for each action.","title":"Actions"},{"location":"client_cli/#example-download-a-pdf","text":"PYTHONPATH=. python -m client_cli.main --action retrieve --object-id Q6190920 --output . This saves the first returned component to the current directory, honoring the server-provided original filename when available.","title":"Example: download a PDF"},{"location":"docker/","text":"Build and run the DOIP server in a container. Build From the project root: docker build -f docker/Dockerfile -t mardi-doip-server . By default the image generates a self-signed cert (CN=localhost) during build. To skip generation, set: docker build -f docker/Dockerfile --build-arg GENERATE_SELF_SIGNED=false -t mardi-doip-server . Run Expose the default DOIP port (plaintext) and the compatibility listener: docker run --rm -p 3567:3567 -p 3568:3568 mardi-doip-server TLS The server auto-enables TLS when both certs/server.crt and certs/server.key are present. With Docker, mount your certificate directory into /app/certs so the container can detect and load them: docker run --rm -p 3567:3567 -p 3568:3568 \\ -v $(pwd)/certs:/app/certs \\ mardi-doip-server Inside the container, the entrypoint checks for /app/certs/server.crt and /app/certs/server.key and, if found, starts TLS listeners on 3567/3568. Without the mount, the server stays in plaintext mode. The container entrypoint runs python -m doip_server.main .","title":"Docker"},{"location":"docker/#build","text":"From the project root: docker build -f docker/Dockerfile -t mardi-doip-server . By default the image generates a self-signed cert (CN=localhost) during build. To skip generation, set: docker build -f docker/Dockerfile --build-arg GENERATE_SELF_SIGNED=false -t mardi-doip-server .","title":"Build"},{"location":"docker/#run","text":"Expose the default DOIP port (plaintext) and the compatibility listener: docker run --rm -p 3567:3567 -p 3568:3568 mardi-doip-server","title":"Run"},{"location":"docker/#tls","text":"The server auto-enables TLS when both certs/server.crt and certs/server.key are present. With Docker, mount your certificate directory into /app/certs so the container can detect and load them: docker run --rm -p 3567:3567 -p 3568:3568 \\ -v $(pwd)/certs:/app/certs \\ mardi-doip-server Inside the container, the entrypoint checks for /app/certs/server.crt and /app/certs/server.key and, if found, starts TLS listeners on 3567/3568. Without the mount, the server stays in plaintext mode. The container entrypoint runs python -m doip_server.main .","title":"TLS"},{"location":"server/","text":"Overview The server implements strict DOIP v2.0 framing with the following operations: Hello (0x01) Retrieve (0x02) Invoke (0x05) It listens on port 3567 by default (3568 for the compatibility JSON listener). Entrypoint Module: doip_server.main Run: python -m doip_server.main Example (plaintext): PYTHONPATH=. python -m doip_server.main --port 3567 Handlers handle_hello Motivation : Allow clients to verify connectivity and discover supported operations without performing data transfers. Use case : A monitoring probe or client bootstrap issues hello to confirm the endpoint is alive and reads the availableOperations map. handle_retrieve Motivation : Deliver FAIR Digital Object bitstreams/components via strict DOIP framing. Use case : A client requests doip:bitstream/Q123/main-pdf to download the canonical PDF for object Q123 ; the handler fetches the bytes from storage and streams component blocks back. handle_invoke Motivation : Trigger server-side workflows that derive new components or metadata from an object. Use case : A client invokes the equation_extraction workflow on Q123 to produce a JSON of extracted equations and receive the derived component and workflow result metadata. Protocol Header: >BBBBHI Blocks: metadata, component, workflow. See doip_server/protocol.py for framing details.","title":"Server"},{"location":"server/#overview","text":"The server implements strict DOIP v2.0 framing with the following operations: Hello (0x01) Retrieve (0x02) Invoke (0x05) It listens on port 3567 by default (3568 for the compatibility JSON listener).","title":"Overview"},{"location":"server/#entrypoint","text":"Module: doip_server.main Run: python -m doip_server.main Example (plaintext): PYTHONPATH=. python -m doip_server.main --port 3567","title":"Entrypoint"},{"location":"server/#handlers","text":"handle_hello Motivation : Allow clients to verify connectivity and discover supported operations without performing data transfers. Use case : A monitoring probe or client bootstrap issues hello to confirm the endpoint is alive and reads the availableOperations map. handle_retrieve Motivation : Deliver FAIR Digital Object bitstreams/components via strict DOIP framing. Use case : A client requests doip:bitstream/Q123/main-pdf to download the canonical PDF for object Q123 ; the handler fetches the bytes from storage and streams component blocks back. handle_invoke Motivation : Trigger server-side workflows that derive new components or metadata from an object. Use case : A client invokes the equation_extraction workflow on Q123 to produce a JSON of extracted equations and receive the derived component and workflow result metadata.","title":"Handlers"},{"location":"server/#protocol","text":"Header: >BBBBHI Blocks: metadata, component, workflow. See doip_server/protocol.py for framing details.","title":"Protocol"}]}